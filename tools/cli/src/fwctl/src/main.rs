// Copyright 2025 The Rustux Authors
//
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT

//! Rustica Firewall Controller (fwctl)
//!
//! Firewall management tool with nftables-style syntax.

use anyhow::{Context, Result};
use clap::{Parser, Subcommand};
use std::fs;
use std::path::PathBuf;

/// Rustica Firewall Controller
#[derive(Parser, Debug)]
#[command(name = "fwctl")]
#[command(about = "Rustica Firewall Controller", long_about = None)]
struct Args {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand, Debug)]
enum Commands {
    /// Show firewall status
    Status,

    /// Load firewall rules
    Load {
        /// Rules file
        #[arg(short, long)]
        file: Option<String>,
    },

    /// Save firewall rules
    Save {
        /// Output file
        #[arg(short, long)]
        file: Option<String>,
    },

    /// Add rule
    Add {
        /// Chain (input, output, forward)
        #[arg(short, long)]
        chain: String,

        /// Protocol (tcp, udp, icmp, all)
        #[arg(short, long)]
        protocol: Option<String>,

        /// Source address
        #[arg(short = 's', long)]
        source: Option<String>,

        /// Destination port
        #[arg(short = 'd', long)]
        dport: Option<u16>,

        /// Action (accept, reject, drop)
        #[arg(short, long)]
        action: String,
    },

    /// Delete rule
    Delete {
        /// Rule number
        #[arg(short, long)]
        number: u32,

        /// Chain
        #[arg(short, long)]
        chain: String,
    },

    /// List rules
    List {
        /// Chain (optional, lists all if not specified)
        chain: Option<String>,
    },

    /// Flush rules
    Flush {
        /// Chain (optional, flushes all if not specified)
        chain: Option<String>,
    },

    /// Set default policy
    Policy {
        /// Chain
        chain: String,

        /// Policy (accept, drop, reject)
        policy: String,
    },
}

#[derive(Debug, Clone)]
struct FirewallRule {
    chain: String,
    protocol: Option<String>,
    source: Option<String>,
    destination: Option<String>,
    dport: Option<u16>,
    action: String,
}

#[derive(Debug)]
struct FirewallConfig {
    default_policy: String,
    rules: Vec<FirewallRule>,
}

impl FirewallConfig {
    fn new() -> Self {
        Self {
            default_policy: "drop".to_string(),
            rules: Vec::new(),
        }
    }

    fn add_default_rules(&mut self) {
        // Allow loopback
        self.rules.push(FirewallRule {
            chain: "input".to_string(),
            protocol: None,
            source: Some("127.0.0.1".to_string()),
            destination: None,
            dport: None,
            action: "accept".to_string(),
        });

        // Allow ICMP ping
        self.rules.push(FirewallRule {
            chain: "input".to_string(),
            protocol: Some("icmp".to_string()),
            source: None,
            destination: None,
            dport: None,
            action: "accept".to_string(),
        });

        // Allow established connections
        self.rules.push(FirewallRule {
            chain: "input".to_string(),
            protocol: Some("tcp".to_string()),
            source: None,
            destination: None,
            dport: None,
            action: "accept".to_string(),
        });

        // Allow SSH (optional, can be configured)
        self.rules.push(FirewallRule {
            chain: "input".to_string(),
            protocol: Some("tcp".to_string()),
            source: None,
            destination: None,
            dport: Some(22),
            action: "accept".to_string(),
        });
    }
}

struct Firewall {
    config_path: PathBuf,
    config: FirewallConfig,
}

impl Firewall {
    fn new() -> Result<Self> {
        let config_path = PathBuf::from("/etc/rustica/firewall.rules");

        let config = if config_path.exists() {
            Self::load_config(&config_path)?
        } else {
            let mut cfg = FirewallConfig::new();
            cfg.add_default_rules();
            cfg
        };

        Ok(Self {
            config_path,
            config,
        })
    }

    fn load_config(path: &PathBuf) -> Result<FirewallConfig> {
        let content = fs::read_to_string(path)?;
        // In production, would parse rules file
        // For now, return default
        let mut config = FirewallConfig::new();
        config.add_default_rules();
        Ok(config)
    }

    fn save_config(&self) -> Result<()> {
        let content = format!(
            "# Rustica Firewall Rules\n\
             # Default policy: {}\n\
             # Generated by fwctl\n\n",
            self.config.default_policy
        );

        for (i, rule) in self.config.rules.iter().enumerate() {
            let proto = rule.protocol.as_ref().map(|p| p.as_str()).unwrap_or("all");
            let source = rule.source.as_ref().map(|s| s.as_str()).unwrap_or("any");
            let dport = rule.dport.map(|p| p.to_string()).unwrap_or("any".to_string());

            fs::write(
                &self.config_path,
                format!(
                    "{}# Rule {}: {} {} {} {} {}\n",
                    content,
                    i + 1,
                    rule.chain,
                    proto,
                    source,
                    dport,
                    rule.action
                ),
            )?;
        }

        Ok(())
    }

    fn show_status(&self) {
        println!("Firewall Status:");
        println!("  Default Policy: {}", self.config.default_policy);
        println!("  Active Rules: {}", self.config.rules.len());
        println!();

        for (i, rule) in self.config.rules.iter().enumerate() {
            println!("  Rule {}: {} chain", i + 1, rule.chain);
            if let Some(ref proto) = rule.protocol {
                println!("    Protocol: {}", proto);
            }
            if let Some(ref source) = rule.source {
                println!("    Source: {}", source);
            }
            if let Some(dport) = rule.dport {
                println!("    Port: {}", dport);
            }
            println!("    Action: {}", rule.action);
            println!();
        }
    }

    fn add_rule(&mut self, chain: String, protocol: Option<String>, source: Option<String>,
                dport: Option<u16>, action: String) -> Result<()> {
        let rule = FirewallRule {
            chain,
            protocol,
            source,
            destination: None,
            dport,
            action,
        };

        self.config.rules.push(rule);
        self.save_config()?;

        println!("Rule added successfully.");

        Ok(())
    }

    fn delete_rule(&mut self, chain: String, number: u32) -> Result<()> {
        let mut index = 0;
        let mut found = false;

        self.config.rules.retain(|rule| {
            if rule.chain == chain {
                index += 1;
                if index == number {
                    found = true;
                    return false;
                }
            }
            true
        });

        if found {
            self.save_config()?;
            println!("Rule {} deleted from {} chain.", number, chain);
        } else {
            println!("Rule {} not found in {} chain.", number, chain);
        }

        Ok(())
    }

    fn list_rules(&self, chain_filter: Option<String>) {
        let mut index = 0;

        for rule in &self.config.rules {
            if let Some(ref filter) = chain_filter {
                if rule.chain != *filter {
                    continue;
                }
            }

            index += 1;
            println!("{} {} -> {}", rule.chain, rule.source.as_ref().unwrap_or(&"any".to_string()), rule.action);
        }

        if index == 0 {
            println!("No rules found.");
        }
    }

    fn flush_rules(&mut self, chain_filter: Option<String>) {
        if let Some(filter) = chain_filter {
            self.config.rules.retain(|r| r.chain != filter);
            println!("Flushed {} chain.", filter);
        } else {
            self.config.rules.clear();
            println!("Flushed all rules.");
        }
    }

    fn set_policy(&mut self, chain: String, policy: String) -> Result<()> {
        // Validate policy
        match policy.as_str() {
            "accept" | "drop" | "reject" => {
                self.config.default_policy = policy;
                self.save_config()?;
                println!("Default policy for {} set to {}.", chain, policy);
                Ok(())
            }
            _ => {
                anyhow::bail!("Invalid policy: {}", policy);
            }
        }
    }
}

fn main() -> Result<()> {
    let args = Args::parse();
    let mut fw = Firewall::new()?;

    match args.command {
        Commands::Status => {
            fw.show_status();
        }
        Commands::Load { file } => {
            // Load rules from file or default path
            let path = if let Some(f) = file {
                PathBuf::from(f)
            } else {
                PathBuf::from("/etc/rustica/firewall.rules")
            };

            if path.exists() {
                println!("Loading firewall rules from {}...", path.display());
                fw.config = Firewall::load_config(&path)?;
                println!("Firewall rules loaded.");
            } else {
                println!("No firewall rules file found at {}", path.display());
            }
        }
        Commands::Save { file } => {
            // Save rules to file
            let path = if let Some(f) = file {
                PathBuf::from(f)
            } else {
                PathBuf::from("/etc/rustica/firewall.rules")
            };

            println!("Saving firewall rules to {}...", path.display());
            fw.save_config()?;
            println!("Firewall rules saved.");
        }
        Commands::Add { chain, protocol, source, dport, action } => {
            fw.add_rule(chain, protocol, source, dport, action)?;
        }
        Commands::Delete { number, chain } => {
            fw.delete_rule(chain, number)?;
        }
        Commands::List { chain } => {
            fw.list_rules(chain);
        }
        Commands::Flush { chain } => {
            fw.flush_rules(chain);
        }
        Commands::Policy { chain, policy } => {
            fw.set_policy(chain, policy)?;
        }
    }

    Ok(())
}
